//! Utilities for manipulating the primary selection
//!
//! The primary selection is an additional protocol modeled after the data device to represent
//! and additional selection (copy/paste), a concept taken from the X11 Server.
//! This primary selection is a shortcut to the common clipboard selection,
//! where text just needs to be selected in order to allow copying it elsewhere
//! The de facto way to perform this action is the middle mouse button, although it is not limited to this one.
//!
//! This module provides the freestanding [`set_primary_focus`] function:
//!   This function sets the data device focus for a given seat; you'd typically call it
//!   whenever the keyboard focus changes, to follow it (for example in the focus hook of your keyboards).
//!
//! The module also provides an additional mechanism allowing your compositor to see and interact with
//! the contents of the primary selection:
//!
//! - the freestanding function [`set_primary_selection`]
//!   allows you to set the contents of the selection for your clients
//! - the `PrimarySelectionHandle` gives you the option to inspect new selections
//!   by overriding [`PrimarySelectionHandler::new_selection].
//!
//! ## Initialization
//!
//! To initialize this implementation, create the [`PrimarySelectionState`], store it inside your `State` struct
//! and implement the [`PrimarySelectionHandler`], as shown in this example:
//!
//! ```
//! # extern crate wayland_server;
//! # #[macro_use] extern crate smithay;
//! use smithay::delegate_primary_selection;
//! use smithay::wayland::primary_selection::{PrimarySelectionState, PrimarySelectionHandler};
//! # use smithay::input::{Seat, SeatHandler, SeatState, pointer::CursorImageStatus};
//! # use smithay::reexports::wayland_server::protocol::wl_surface::WlSurface;
//!
//! # struct State { primary_selection_state: PrimarySelectionState }
//! # let mut display = wayland_server::Display::<State>::new().unwrap();
//! // Create the primary_selection state
//! let primary_selection_state = PrimarySelectionState::new::<State>(
//!     &display.handle(),
//! );
//!
//! // insert the PrimarySelectionState into your state
//! // ..
//!
//! // implement the necessary traits
//! # impl SeatHandler for State {
//! #     type KeyboardFocus = WlSurface;
//! #     type PointerFocus = WlSurface;
//! #     fn seat_state(&mut self) -> &mut SeatState<Self> { unimplemented!() }
//! #     fn focus_changed(&mut self, seat: &Seat<Self>, focused: Option<&WlSurface>) { unimplemented!() }
//! #     fn cursor_image(&mut self, seat: &Seat<Self>, image: CursorImageStatus) { unimplemented!() }
//! # }
//! impl PrimarySelectionHandler for State {
//!     fn primary_selection_state(&self) -> &PrimarySelectionState { &self.primary_selection_state }
//!     // ... override default implementations here to customize handling ...
//! }
//! delegate_primary_selection!(State);
//!
//! // You're now ready to go!
//! ```

use std::collections::HashMap;
use std::{cell::RefCell, sync::Arc};

use std::os::unix::io::{AsRawFd, OwnedFd};

use tracing::{debug, instrument};
use wayland_protocols_wlr::data_control::v1::server;
use wayland_server::{
    backend::GlobalId,
    backend::{protocol::Message, ClientId, Handle, ObjectData, ObjectId},
    Client, DisplayHandle, GlobalDispatch, Resource,
};

use crate::{
    input::{Seat, SeatHandler},
    utils::IsAlive,
};

pub use source::{with_source_metadata, Data, Metadata};

pub use self::{device::Device, manager::Manager, offer::Offer, source::Source};

mod device;
mod manager;
mod offer;
mod source;

/// Events that are generated by interactions of the clients with the data device
pub trait Handler: Sized {
    /// A client has set the selection
    #[allow(unused_variables)]
    fn new_selection(&mut self, source: Option<Source>) {}

    /// A client requested to read the server-set selection
    ///
    /// * `mime_type` - the requested mime type
    /// * `fd` - the fd to write into
    #[allow(unused_variables)]
    fn send_selection(&mut self, mime_type: String, fd: OwnedFd) {}
}

pub struct State<D: SeatHandler> {
    manager_global: GlobalId,
    seats: HashMap<Seat<D>, SeatData>,
}

impl<D: SeatHandler> State<D> {
    /// Regiseter new [ZwpPrimarySelectionDeviceManagerV1] global
    pub fn new(display: &DisplayHandle) -> Self
    where
        D: GlobalDispatch<Manager, ()> + 'static,
        D: Handler,
    {
        let manager_global = display.create_global::<D, Manager, _>(1, ());

        Self {
            manager_global,
            seats: HashMap::new(),
        }
    }

    /// [ZwpPrimarySelectionDeviceManagerV1] GlobalId getter
    pub fn global(&self) -> GlobalId {
        self.manager_global.clone()
    }
}

/// Set the primary selection focus to a certain client for a given seat
#[instrument(name = "wayland_primary_selection", level = "debug", skip(dh, seat, client), fields(seat = seat.name(), client = ?client.as_ref().map(|c| c.id())))]
pub fn set_primary_focus<D>(dh: &DisplayHandle, seat: &Seat<D>, client: Option<Client>)
where
    D: SeatHandler + Handler + 'static,
{
    seat.user_data()
        .insert_if_missing(|| RefCell::new(SeatData::new()));
    let seat_data = seat.user_data().get::<RefCell<SeatData>>().unwrap();
    seat_data.borrow_mut().set_focus::<D>(dh, client);
}

/// Set a compositor-provided primary selection for this seat
///
/// You need to provide the available mime types for this selection.
///
/// Whenever a client requests to read the selection, your callback will
/// receive a [`PrimarySelectionHandler::send_selection`] event.
#[instrument(name = "wayland_primary_selection", level = "debug", skip(dh, seat), fields(seat = seat.name()))]
pub fn set_primary_selection<D>(dh: &DisplayHandle, seat: &Seat<D>, mime_types: Vec<String>)
where
    D: SeatHandler + Handler + 'static,
{
    seat.user_data()
        .insert_if_missing(|| RefCell::new(SeatData::new()));
    let seat_data = seat.user_data().get::<RefCell<SeatData>>().unwrap();
    seat_data
        .borrow_mut()
        .set_selection::<D>(dh, Selection::Compositor(Metadata { mime_types }));
}

pub enum Selection {
    Empty,
    Client(Source),
    Compositor(source::Metadata),
}

pub struct SeatData {
    known_devices: Vec<Device>,
    selection: Selection,
    current_focus: Option<wayland_server::Client>,
}

impl Default for SeatData {
    fn default() -> Self {
        Self {
            known_devices: Vec::new(),
            selection: Selection::Empty,
            current_focus: None,
        }
    }
}

impl SeatData {
    pub fn new() -> Self {
        Self::default()
    }

    pub fn add_device(&mut self, device: Device) {
        self.known_devices.push(device);
    }

    pub fn retain_devices<F>(&mut self, f: F)
    where
        F: FnMut(&Device) -> bool,
    {
        self.known_devices.retain(f)
    }

    pub fn set_focus<D>(&mut self, dh: &DisplayHandle, new_focus: Option<wayland_server::Client>)
    where
        D: Handler,
        D: 'static,
    {
        self.current_focus = new_focus;
        self.send_selection::<D>(dh);
    }

    pub fn set_selection<D>(&mut self, dh: &DisplayHandle, new_selection: Selection)
    where
        D: Handler,
        D: 'static,
    {
        if let Selection::Client(source) = &self.selection {
            match &new_selection {
                Selection::Client(new_source) if new_source == source => {}
                _ => {
                    source.cancelled();
                }
            }
        }
        self.selection = new_selection;
        self.send_selection::<D>(dh);
    }

    pub fn send_selection<D>(&mut self, dh: &DisplayHandle)
    where
        D: Handler,
        D: 'static,
    {
        let client = match self.current_focus.as_ref() {
            Some(c) => c,
            None => return,
        };
        // first sanitize the selection, reseting it to null if the client holding
        // it dropped it
        let cleanup = if let Selection::Client(ref source) = self.selection {
            !source.alive()
        } else {
            false
        };
        if cleanup {
            self.selection = Selection::Empty;
        }

        // then send it if appropriate
        match self.selection {
            Selection::Empty => {
                // send an empty selection
                for pd in &self.known_devices {
                    // skip data devices not belonging to our client
                    if dh.get_client(pd.id()).map(|c| &c != client).unwrap_or(true) {
                        continue;
                    }
                    pd.selection(None);
                }
            }
            Selection::Client(ref source) => {
                for pd in &self.known_devices {
                    // skip data devices not belonging to our client
                    if dh.get_client(pd.id()).map(|c| &c != client).unwrap_or(true) {
                        continue;
                    }
                    let source_clone = source.clone();

                    let handle = dh.backend_handle();
                    // create a data offer
                    let offer = handle
                        .create_object::<D>(
                            client.id(),
                            Offer::interface(),
                            pd.version(),
                            Arc::new(ClientSelection { source: source_clone }),
                        )
                        .unwrap();
                    let offer = Offer::from_id(dh, offer).unwrap();

                    // advertize the offer to the client
                    pd.data_offer(&offer);
                    with_source_metadata(source, |meta| {
                        for mime_type in meta.mime_types.iter().cloned() {
                            offer.offer(mime_type);
                        }
                    })
                    .unwrap();
                    pd.selection(Some(&offer));
                }
            }
            Selection::Compositor(ref meta) => {
                for pd in &self.known_devices {
                    // skip data devices not belonging to our client
                    if dh.get_client(pd.id()).map(|c| &c != client).unwrap_or(true) {
                        continue;
                    }

                    let offer_meta = meta.clone();

                    let handle = dh.backend_handle();
                    // create a data offer
                    let offer = handle
                        .create_object::<D>(
                            client.id(),
                            Offer::interface(),
                            pd.version(),
                            Arc::new(ServerSelection { offer_meta }),
                        )
                        .unwrap();
                    let offer = Offer::from_id(dh, offer).unwrap();

                    // advertize the offer to the client
                    pd.data_offer(&offer);
                    for mime_type in meta.mime_types.iter().cloned() {
                        offer.offer(mime_type);
                    }
                    pd.selection(Some(&offer));
                }
            }
        }
    }
}

struct ClientSelection {
    source: Source,
}

impl<D> ObjectData<D> for ClientSelection
where
    D: Handler,
{
    fn request(
        self: Arc<Self>,
        dh: &Handle,
        _handler: &mut D,
        _client_id: ClientId,
        msg: Message<ObjectId, OwnedFd>,
    ) -> Option<Arc<dyn ObjectData<D>>> {
        let dh = DisplayHandle::from(dh.clone());
        if let Ok((_resource, request)) = Offer::parse_request(&dh, msg) {
            handle_client_selection(request, &self.source);
        }

        None
    }

    fn destroyed(&self, _data: &mut D, _client_id: ClientId, _object_id: ObjectId) {}
}

fn handle_client_selection(request: offer::Request, source: &Source) {
    // selection data offers only care about the `receive` event
    if let offer::Request::Receive { fd, mime_type } = request {
        // check if the source and associated mime type is still valid
        let valid =
            with_source_metadata(source, |meta| meta.mime_types.contains(&mime_type)).unwrap_or(false);
        // TODO:?
        // && source.as_ref().is_alive();
        if !valid {
            // deny the receive
            debug!("Denying a zwp_primary_selection_offer_v1.receive with invalid source.");
        } else {
            source.send(mime_type, fd.as_raw_fd());
        }
    }
}

struct ServerSelection {
    offer_meta: Metadata,
}

impl<D> ObjectData<D> for ServerSelection
where
    D: Handler,
{
    fn request(
        self: Arc<Self>,
        dh: &Handle,
        handler: &mut D,
        _client_id: ClientId,
        msg: Message<ObjectId, OwnedFd>,
    ) -> Option<Arc<dyn ObjectData<D>>> {
        let dh = DisplayHandle::from(dh.clone());
        if let Ok((_resource, request)) = Offer::parse_request(&dh, msg) {
            handle_server_selection(handler, request, &self.offer_meta);
        }

        None
    }

    fn destroyed(&self, _data: &mut D, _client_id: ClientId, _object_id: ObjectId) {}
}

pub fn handle_server_selection<D>(handler: &mut D, request: offer::Request, offer_meta: &Metadata)
where
    D: Handler,
{
    // selection data offers only care about the `receive` event
    if let offer::Request::Receive { fd, mime_type } = request {
        // check if the associated mime type is valid
        if !offer_meta.mime_types.contains(&mime_type) {
            // deny the receive
            debug!("Denying a zwp_primary_selection_offer_v1.receive with invalid source.");
        } else {
            handler.send_selection(mime_type, fd);
        }
    }
}

#[allow(missing_docs)] // TODO
#[macro_export]
macro_rules! delegate {
    ($(@<$( $lt:tt $( : $clt:tt $(+ $dlt:tt )* )? ),+>)? $ty: ty) => {
        $crate::reexports::wayland_server::delegate_global_dispatch!($(@< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)? $ty: [
            $crate::reexports::wayland_protocols::wp::primary_selection::zv1::server::zwp_primary_selection_device_manager_v1::ZwpPrimarySelectionDeviceManagerV1: ()
        ] => $crate::wayland::primary_selection::PrimarySelectionState);

        $crate::reexports::wayland_server::delegate_dispatch!($(@< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)? $ty: [
            $crate::reexports::wayland_protocols::wp::primary_selection::zv1::server::zwp_primary_selection_device_manager_v1::ZwpPrimarySelectionDeviceManagerV1: ()
        ] => $crate::wayland::primary_selection::PrimarySelectionState);
        $crate::reexports::wayland_server::delegate_dispatch!($(@< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)? $ty: [
            $crate::reexports::wayland_protocols::wp::primary_selection::zv1::server::zwp_primary_selection_device_v1::ZwpPrimarySelectionDeviceV1: $crate::wayland::primary_selection::PrimaryDeviceUserData
        ] => $crate::wayland::primary_selection::PrimarySelectionState);
        $crate::reexports::wayland_server::delegate_dispatch!($(@< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)? $ty: [
            $crate::reexports::wayland_protocols::wp::primary_selection::zv1::server::zwp_primary_selection_source_v1::ZwpPrimarySelectionSourceV1: $crate::wayland::primary_selection::PrimarySourceUserData
        ] => $crate::wayland::primary_selection::PrimarySelectionState);
    };
}
